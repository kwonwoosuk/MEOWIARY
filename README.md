# ğŸ“ğŸˆMEOWIARY

ë°˜ë ¤ë¬˜ ì¼ìƒ ì‚¬ì§„ê¸°ë¡ì„ ë‚¨ê¸°ê³  ì¦ìƒì„ ê°„í¸í•˜ê²Œ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ì•±ì…ë‹ˆë‹¤

<div align="center">
    
| ì¸ì•± ìŠ¤í¬ë¦°ìƒ· |
|:---:|
| <img width="1000" alt="á„‰á…¢á„Šá…¡á†¨ á„‰á…³á„á…©á„‹á…¥ á„Œá…¦á„á…®á†¯ á„‹á…¢á†¸á„‰á…¡á„Œá…µá†«" src="https://github.com/user-attachments/assets/6790b609-d965-479d-a7e2-e73eed61db1d" /> | 

</div>



## ğŸ“‹ ëª©ì°¨

- í”„ë¡œì íŠ¸ ì†Œê°œ
- ì£¼ìš”ê¸°ëŠ¥
- ê¸°ìˆ  ìŠ¤íƒ
- í”„ë¡œì íŠ¸ êµ¬ì¡°
- ì£¼ìš” êµ¬í˜„ ë‚´ìš©
- íŠ¸ëŸ¬ë¸” ìŠˆíŒ…

## í”„ë¡œì íŠ¸ ì†Œê°œ

MEOWIARYëŠ” ë°˜ë ¤ë¬˜ì˜ ì¼ìƒì„ ê¸°ë¡í•˜ê³  ê±´ê°• ìƒíƒœë¥¼ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ì•±ì…ë‹ˆë‹¤.  
ì‚¬ìš©ìëŠ” ë°˜ë ¤ë¬˜ì˜ ì¼ìƒì„ ì‚¬ì§„ê³¼ í•¨ê»˜ ê¸°ë¡í•˜ê³ , ì¦ìƒì„ ê°„í¸í•˜ê²Œ ê´€ë¦¬í•˜ë©°  
ì‘ê¸‰ìƒí™©ì‹œ ë¹ ë¥´ê²Œ ì£¼ë³€ 24ì‹œ ë™ë¬¼ë³‘ì›ì„ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ì›”ë³„ ìº˜ë¦°ë” ê¸°ëŠ¥ì„ í†µí•´ ê¸°ë¡ì„ í•œëˆˆì— í™•ì¸í•  ìˆ˜ ìˆìœ¼ë©°  
ì¦ìƒì˜ ì‹¬ê°ë„ì™€ íŠ¹ì§•ì„ ì‰½ê²Œ ê¸°ë¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 

## â­ï¸ ì£¼ìš” ê¸°ëŠ¥


- **ì¼ìƒ ê¸°ë¡**: ë°˜ë ¤ë¬˜ì˜ ì¼ìƒì„ ì‚¬ì§„ê³¼ í•¨ê»˜ ê¸°ë¡
- **ì¦ìƒ ê´€ë¦¬**: ë°˜ë ¤ë¬˜ì˜ ê±´ê°• ì´ìƒ ì¦ìƒì„ ì‹¬ê°ë„ì™€ í•¨ê»˜ ê¸°ë¡
- **ìº˜ë¦°ë” ë·°**: ì›”ë³„ ê¸°ë¡ì„ ìº˜ë¦°ë” í˜•íƒœë¡œ í™•ì¸
- **24ì‹œ ë³‘ì› ê²€ìƒ‰**: ìœ„ì¹˜ ê¸°ë°˜ ì£¼ë³€ 24ì‹œ ë™ë¬¼ë³‘ì› ê²€ìƒ‰
- **ì´ë¯¸ì§€ ê´€ë¦¬**: ê°¤ëŸ¬ë¦¬ í˜•íƒœë¡œ ê¸°ë¡ëœ ì‚¬ì§„ ëª¨ì•„ë³´ê¸°
- **ë¯¸ë””ì–´ ìƒì„±**: ë‹¤ì¤‘ ì´ë¯¸ì§€ë¡œ GIF/ë™ì˜ìƒ ìƒì„±

## ğŸ›  ê¸°ìˆ  ìŠ¤íƒ


![image](https://github.com/user-attachments/assets/413ab3d1-3fd2-4b21-93ae-0befe5af92f9)





- **ì–¸ì–´ ë° í”„ë ˆì„ì›Œí¬**: Swift, UIKit
- **ì•„í‚¤í…ì²˜**: MVVM + RxSwift Input/Output íŒ¨í„´
- **UI ë ˆì´ì•„ì›ƒ**: SnapKit
- **ë„¤íŠ¸ì›Œí¬ í†µì‹ **: URLSession + Swift Concurrency (async/await)
- **ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°**: RxSwift, RxCocoa
- **ì§€ë„ ì„œë¹„ìŠ¤**: Kakao Maps API
- **ë¡œì»¬ ë°ì´í„°ë² ì´ìŠ¤**: RealmSwift
- **ì´ë¯¸ì§€ ì²˜ë¦¬**: AVFoundation, PhotosUI

## í”„ë¡œì íŠ¸ êµ¬ì¡°

```
MEOWIARY/
â”œâ”€â”€ Models/
â”‚   â”œâ”€â”€ Realm Models/
â”‚   â”‚   â”œâ”€â”€ DayCard.swift
â”‚   â”‚   â”œâ”€â”€ ImageRecord.swift
â”‚   â”‚   â”œâ”€â”€ Symptom.swift
â”‚   â”‚   â”œâ”€â”€ SymptomImage.swift
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ API Models/
â”‚       â”œâ”€â”€ Weather.swift
â”‚       â”œâ”€â”€ Hospital.swift
â”‚       â””â”€â”€ KakaoAPIModels.swift
â”œâ”€â”€ ViewModels/
â”‚   â”œâ”€â”€ HomeViewModel.swift
â”‚   â”œâ”€â”€ DetailViewModel.swift
â”‚   â”œâ”€â”€ GalleryViewModel.swift
â”‚   â”œâ”€â”€ DailyDiaryViewModel.swift
â”‚   â”œâ”€â”€ SymptomRecordViewModel.swift
â”‚   â””â”€â”€ ...
â”œâ”€â”€ Views/
â”‚   â”œâ”€â”€ Controllers/
â”‚   â”‚   â”œâ”€â”€ MWTabBarController.swift
â”‚   â”‚   â”œâ”€â”€ HomeViewController.swift
â”‚   â”‚   â”œâ”€â”€ DailyDiaryViewController.swift
â”‚   â”‚   â”œâ”€â”€ SymptomRecordViewController.swift
â”‚   â”‚   â”œâ”€â”€ GalleryViewController.swift
â”‚   â”‚   â”œâ”€â”€ DetailViewController.swift
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ Cells/
â”‚   â”‚   â”œâ”€â”€ GalleryCell.swift
â”‚   â”‚   â”œâ”€â”€ CardCell.swift
â”‚   â”‚   â”œâ”€â”€ ImageCell.swift
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ Common/
â”‚       â”œâ”€â”€ BaseView.swift
â”‚       â”œâ”€â”€ BaseViewController.swift
â”‚       â”œâ”€â”€ NavigationBarView.swift
â”‚       â””â”€â”€ ...
â”œâ”€â”€ Utils/
â”‚   â”œâ”€â”€ Extensions/
â”‚   â”‚   â”œâ”€â”€ UIColor+Extension.swift
â”‚   â”‚   â”œâ”€â”€ UILabel+Date.swift
â”‚   â”‚   â”œâ”€â”€ UIViewController+Extension.swift
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ Constants/
â”‚   â”‚   â”œâ”€â”€ DesignSystem.swift
â”‚   â”‚   â”œâ”€â”€ Constants.swift
â”‚   â”‚   â””â”€â”€ ...
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ Network/
â”‚   â”‚   â”œâ”€â”€ NetworkManager.swift
â”‚   â”‚   â”œâ”€â”€ WeatherService.swift
â”‚   â”‚   â”œâ”€â”€ KakaoMapManager.swift
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ Database/
â”‚       â”œâ”€â”€ DayCardRepository.swift
â”‚       â”œâ”€â”€ ImageRecordRepository.swift
â”‚       â”œâ”€â”€ SymptomRepository.swift
â”‚       â””â”€â”€ ...
â””â”€â”€ Resources/
    â”œâ”€â”€ Assets.xcassets
    â””â”€â”€ Info.plist

```

## ğŸ” ì£¼ìš” êµ¬í˜„ ë‚´ìš©

### 1. MVVM + RxSwift Input/Output íŒ¨í„´

ëª¨ë“  ViewModelì€ `BaseViewModel` í”„ë¡œí† ì½œì„ ì¤€ìˆ˜í•˜ì—¬ ì¼ê´€ëœ ì•„í‚¤í…ì²˜ë¥¼ ìœ ì§€í–ˆìŠµë‹ˆë‹¤.

```swift
protocol BaseViewModel {
    var disposeBag: DisposeBag { get }

    associatedtype Input
    associatedtype Output

    func transform(input: Input) -> Output
}

```

ê° ViewModelì€ ì´ íŒ¨í„´ì„ ì¤€ìˆ˜í•˜ì—¬ ë·°ì™€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ëª…í™•íˆ ë¶„ë¦¬í–ˆìŠµë‹ˆë‹¤.

```swift
// HomeViewModel ì˜ˆì‹œ
class HomeViewModel: BaseViewModel {
    var disposeBag = DisposeBag()

    // í˜„ì¬ ì—°ë„ì™€ ì›” ê´€ë¦¬ë¥¼ ìœ„í•œ Subject
    let yearSubject = BehaviorRelay<Int>(value: Calendar.current.component(.year, from: Date()))
    let monthSubject = BehaviorRelay<Int>(value: Calendar.current.component(.month, from: Date()))
    let isShowingSymptomsSubject = BehaviorRelay<Bool>(value: false)
    private let weatherInfoRelay = BehaviorRelay<Weather?>(value: nil)

    struct Input {
        let viewDidLoad: Observable<Void>
        let yearNavPrev: Observable<Void>
        let yearNavNext: Observable<Void>
        let toggleViewTap: Observable<Void>
    }

    struct Output {
        let currentYear: Driver<String>
        let currentMonth: Driver<Int>
        let isShowingSymptoms: Driver<Bool>
        let toggleButtonStyle: Driver<ToggleButtonStyle>
        let weatherInfo: Driver<Weather?>
    }

    func transform(input: Input) -> Output {
        // Input ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•˜ì—¬ Outputìœ¼ë¡œ ë³€í™˜
        input.yearNavPrev
            .subscribe(onNext: { [weak self] in
                self?.decrementYear()
            })
            .disposed(by: disposeBag)

        // ë‹¤ë¥¸ Input ì´ë²¤íŠ¸ ì²˜ë¦¬...

        return Output(
            currentYear: yearSubject.map { String($0) }.asDriver(onErrorJustReturn: ""),
            currentMonth: monthSubject.asDriver(),
            isShowingSymptoms: isShowingSymptomsSubject.asDriver(),
            toggleButtonStyle: isShowingSymptomsSubject.asDriver(onErrorJustReturn: defaultStyle),
            weatherInfo: weatherInfoRelay.asDriver()
        )
    }
}

```

### 2. ê³µí†µ UI ì»´í¬ë„ŒíŠ¸ ê´€ë¦¬

ì¤‘ë³µë˜ëŠ” UI ìš”ì†ŒëŠ” ë² ì´ìŠ¤ í´ë˜ìŠ¤ë¡œ ì¶”ìƒí™”í•˜ì—¬ ì¬ì‚¬ìš©ì„±ì„ ë†’ì˜€ìŠµë‹ˆë‹¤.

```swift
// UI ì»´í¬ë„ŒíŠ¸ì˜ ê¸°ë³¸ ë ˆì´ì•„ì›ƒ ì„¤ì •ì„ ìœ„í•œ BaseView
class BaseView: UIView {
    override init(frame: CGRect) {
        super.init(frame: frame)
        configureHierarchy()
        configureLayout()
        configureView()
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    func configureHierarchy() { }
    func configureLayout() { }
    func configureView() { }
}

// ViewControllerì˜ ê³µí†µ ì„¤ì •ì„ ìœ„í•œ BaseViewController
class BaseViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = .white
        configureHierarchy()
        configureLayout()
        configureView()
        bind()
        setupKeyboardDismissGesture()
    }

    func configureHierarchy() { }
    func configureLayout() { }
    func configureView() { }
    func bind() { }

    func setupKeyboardDismissGesture() {
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(dismissKeyboard))
        tapGesture.cancelsTouchesInView = false
        view.addGestureRecognizer(tapGesture)
    }

    @objc func dismissKeyboard() {
        view.endEditing(true)
    }
}

```

### 3. ë””ìì¸ ì‹œìŠ¤í…œ êµ¬í˜„

ì¼ê´€ëœ ë””ìì¸ ìš”ì†Œë¥¼ ìœ„í•œ ë””ìì¸ ì‹œìŠ¤í…œì„ ì—´ê±°í˜•ìœ¼ë¡œ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

```swift
enum DesignSystem {
    enum Color {
        enum Tint: String {
            case main = "FF6A6A"
            case action = "42A5F5"
            case lightGray = "F2F2F2"
            case text = "333333"
            case darkGray = "666666"
            // ...

            func inUIColor() -> UIColor {
                return UIColor(hex: self.rawValue)
            }
        }

        enum Background: String {
            case main = "FFFFFF"
            case card = "63C7FE"
            case lightBlue = "E3F2FD"
            // ...

            func inUIColor() -> UIColor {
                return UIColor(hex: self.rawValue)
            }
        }

        enum Status: String {
            case negative1 = "9E9E9E"   // ê²½ì¦ (íšŒìƒ‰)
            case negative2 = "f0e936"   // êµ¬í†  (ë…¸ë€ìƒ‰)
            case negative3 = "FF9800"   // ê²½ê³  (ì£¼í™©ìƒ‰)
            case negative4 = "F44336"   // ì¤‘ì¦ (ë¹¨ê°„ìƒ‰)
            case negative5 = "7a1c1a"   // í˜ˆë³€ë“± (ê°ˆìƒ‰)

            func inUIColor() -> UIColor {
                return UIColor(hex: self.rawValue)
            }
        }
    }

    enum Font {
        enum Size {
            static let small: CGFloat = 12
            static let regular: CGFloat = 14
            static let medium: CGFloat = 16
            static let large: CGFloat = 22
            static let extraLarge: CGFloat = 32
        }

        enum Weight {
            static func regular(size: CGFloat) -> UIFont {
                return .systemFont(ofSize: size)
            }

            static func bold(size: CGFloat) -> UIFont {
                return .boldSystemFont(ofSize: size)
            }
        }
    }

    enum Layout {
        static let standardMargin: CGFloat = 20
        static let smallMargin: CGFloat = 10
        static let cornerRadius: CGFloat = 8
        static let largeCornerRadius: CGFloat = 20
    }
}

```

### 4. ë ˆì´ì•„ì›ƒ ëŒ€ì‘ì„± í–¥ìƒ

ë‹¤ì–‘í•œ í™”ë©´ í¬ê¸°ì— ëŒ€ì‘í•˜ëŠ” ë ˆì´ì•„ì›ƒ ì„¤ê³„ë¥¼ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

```swift
// ê¸°ê¸° íŠ¹ì„±ì— ë”°ë¥¸ ë ˆì´ì•„ì›ƒ ì¡°ì •
extension DesignSystem {
    enum Device {
        enum ScreenType {
            case small      // iPhone SE, 5.4ì¸ì¹˜ ë¯¸ë§Œ (height <= 667)
            case medium     // iPhone 8 Plus ~ iPhone 13, 5.5~6.1ì¸ì¹˜ (667 < height <= 844)
            case large      // iPhone 13 Pro Max ì´ìƒ, 6.5ì¸ì¹˜ ì´ìƒ (844 < height)

            static var current: ScreenType {
                let height = UIScreen.main.bounds.height
                if height <= 667 {
                    return .small
                } else if height <= 844 {
                    return .medium
                } else {
                    return .large
                }
            }
        }

        static var isSmallScreen: Bool {
            return ScreenType.current == .small
        }

        static var isMediumnScreen: Bool {
            return ScreenType.current == .medium
        }

        static var isLargeScreen: Bool {
            return ScreenType.current == .large
        }
    }
}

// ë ˆì´ì•„ì›ƒ ì„¤ì • ì˜ˆì‹œ
private func configureLayout() {
    let isSmallScreen = DesignSystem.Device.isSmallScreen

    dateLabel.snp.makeConstraints { make in
        make.top.equalToSuperview().offset(DesignSystem.Layout.standardMargin)
        make.leading.trailing.equalToSuperview().inset(DesignSystem.Layout.standardMargin)
    }

    photoButton.snp.makeConstraints { make in
        make.top.equalTo(dayOfWeekLabel.snp.bottom).offset(DesignSystem.Layout.standardMargin)
        make.leading.trailing.equalTo(dateLabel)
        make.height.equalTo(isSmallScreen ? 150 : 180) // í™”ë©´ í¬ê¸°ì— ë”°ë¥¸ ë†’ì´ ì¡°ì •
    }
}

```

### 5. ë„¤íŠ¸ì›Œí¬ ê³„ì¸µ ì„¤ê³„

Swift Concurrencyë¥¼ í™œìš©í•œ ë„¤íŠ¸ì›Œí¬ í†µì‹  ê³„ì¸µì„ ì„¤ê³„í–ˆìŠµë‹ˆë‹¤.

```swift
// ë„¤íŠ¸ì›Œí¬ ë§¤ë‹ˆì €
final class NetworkManager {

    // MARK: - Properties
    static let shared = NetworkManager()

    private init() {}

    private let session = URLSession.shared

    // MARK: - Public Methods

    /// ë¹„ë™ê¸° ë°ì´í„° ìš”ì²­ (Swift Concurrency)
    func request<T: Decodable>(
        endpoint: String,
        queryItems: [URLQueryItem]? = nil,
        httpMethod: String = "GET",
        headers: [String: String]? = nil
    ) async throws -> T {

        // URL ìƒì„±
        guard var urlComponents = URLComponents(string: endpoint) else {
            throw NetworkError.invalidURL
        }

        if let queryItems = queryItems {
            urlComponents.queryItems = queryItems
        }

        guard let url = urlComponents.url else {
            throw NetworkError.invalidURL
        }

        // ìš”ì²­ ìƒì„±
        var request = URLRequest(url: url)
        request.httpMethod = httpMethod

        // ê¸°ë³¸ í—¤ë” ì„¤ì •
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        // ì¶”ê°€ í—¤ë” ì„¤ì •
        headers?.forEach { key, value in
            request.setValue(value, forHTTPHeaderField: key)
        }

        // ìš”ì²­ ì „ì†¡ ë° ì‘ë‹µ ì²˜ë¦¬
        do {
            let (data, response) = try await session.data(for: request)

            // HTTP ìƒíƒœ ì½”ë“œ í™•ì¸
            guard let httpResponse = response as? HTTPURLResponse else {
                throw NetworkError.unknown(NSError(domain: "HTTPResponse", code: -1))
            }

            // ì„±ê³µ ìƒíƒœ ì½”ë“œ í™•ì¸ (200-299)
            guard (200...299).contains(httpResponse.statusCode) else {
                throw NetworkError.serverError(statusCode: httpResponse.statusCode)
            }

            // ë°ì´í„° ë””ì½”ë”©
            do {
                let decodedData = try JSONDecoder().decode(T.self, from: data)
                return decodedData
            } catch {
                throw NetworkError.decodingError
            }
        } catch let urlError as URLError {
            throw NetworkError.unknown(urlError)
        } catch {
            throw error
        }
    }
}

```

### 6. RealmSwiftë¥¼ í™œìš©í•œ ì €ì¥ì†Œ íŒ¨í„´

ë¡œì»¬ ë°ì´í„°ë² ì´ìŠ¤ ì‘ì—…ì„ ìœ„í•œ ì €ì¥ì†Œ íŒ¨í„´ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

```swift
// DayCard ì €ì¥ì†Œ
class DayCardRepository: DayCardRepositoryProtocol {
    // í•„ìš”í•  ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ Realm ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
    private func getRealm() -> Realm {
        do {
            return try Realm()
        } catch {
            fatalError("Failed to initialize Realm: \(error)")
        }
    }

    // DayCard ì €ì¥
    func saveDayCard(_ dayCard: DayCard) -> Observable<DayCard> {
        return Observable.create { observer in
            let realm = self.getRealm()

            do {
                try realm.write {
                    realm.add(dayCard, update: .modified)
                    print("DayCard ì €ì¥ ì„±ê³µ: \(dayCard.id)")
                }
                observer.onNext(dayCard)
                observer.onCompleted()
            } catch {
                print("DayCard ì €ì¥ ì‹¤íŒ¨: \(error)")
                observer.onError(error)
            }

            return Disposables.create()
        }
    }

    // íŠ¹ì • ë‚ ì§œì˜ DayCard ì¡°íšŒ
    func getDayCardForDate(year: Int, month: Int, day: Int) -> DayCard? {
        let realm = getRealm()
        return realm.objects(DayCard.self)
            .filter("year == %@ AND month == %@ AND day == %@", year, month, day)
            .first
    }

    // ì›”ë³„ DayCard ì¡°íšŒ
    func getDayCards(year: Int, month: Int) -> [DayCard] {
        let realm = getRealm()
        let results = realm.objects(DayCard.self)
            .filter("year == %@ AND month == %@", year, month)
            .sorted(byKeyPath: "day")
        return Array(results)
    }

    // ì´ë¯¸ì§€ ë ˆì½”ë“œ ì¶”ê°€
    func addImageRecord(_ imageRecords: [ImageRecord], to dayCard: DayCard) -> Observable<Void> {
        return Observable.create { observer in
            let realm = self.getRealm()

            guard let localDayCard = realm.object(ofType: DayCard.self, forPrimaryKey: dayCard.id) else {
                observer.onError(NSError(domain: "DayCard not found", code: -1, userInfo: nil))
                return Disposables.create()
            }

            do {
                try realm.write {
                    for imageRecord in imageRecords {
                        localDayCard.imageRecords.append(imageRecord)
                    }
                }
                observer.onNext(())
                observer.onCompleted()
            } catch {
                observer.onError(error)
            }

            return Disposables.create()
        }
    }
}

```

### 7. ìº˜ë¦°ë” ì¹´ë“œ ë·° êµ¬í˜„

ì›”ë³„ ê¸°ë¡ì„ ë³¼ ìˆ˜ ìˆëŠ” í”Œë¦½ ê°€ëŠ¥í•œ ìº˜ë¦°ë” ì¹´ë“œ ë·°ë¥¼ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

```swift
// CardCell.swift (ì¼ë¶€)
func flipToCalendar(animated: Bool = true) {
    // ì´ë¯¸ ë’¤ì§‘íŒ ìƒíƒœë©´ ì¢…ë£Œ
    if isFlipped {
        return
    }

    saveDisplayMode()

    if animated {
        // ì• ë‹ˆë©”ì´ì…˜ ì˜µì…˜ - ì¼ì •í•œ ì†ë„ë¡œ ë’¤ì§‘ê¸°
        UIView.transition(
            with: self.contentView,
            duration: 0.4,
            options: [.transitionFlipFromLeft, .allowUserInteraction, .curveLinear],
            animations: {
                self.containerView.isHidden = true
                self.calendarContainerView.isHidden = false
            },
            completion: { _ in
                self.isFlipped = true
                print("CardCell: \(self.month)ì›” ì¹´ë“œ ë’¤ì§‘ê¸° ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ")
            }
        )
    } else {
        // ì• ë‹ˆë©”ì´ì…˜ ì—†ì´ ì¦‰ì‹œ ìƒíƒœ ë³€ê²½
        containerView.isHidden = true
        calendarContainerView.isHidden = false
        isFlipped = true
    }
}

func createCalendarGrid(with dayCardData: [Int: DayCard] = [:]) {
    let calendar = Calendar.current

    // ì›”ì˜ ì²«ë²ˆì§¸ ë‚ ì§œì™€ ì¼ìˆ˜ ê³„ì‚°
    var components = DateComponents()
    components.year = year
    components.month = month
    components.day = 1

    guard let firstDayOfMonth = calendar.date(from: components) else { return }

    // ì²« ë²ˆì§¸ ìš”ì¼ (1: ì¼ìš”ì¼, 2: ì›”ìš”ì¼, ..., 7: í† ìš”ì¼)
    let firstWeekday = calendar.component(.weekday, from: firstDayOfMonth)
    let numberOfDaysInMonth = calendar.range(of: .day, in: .month, for: firstDayOfMonth)?.count ?? 30

    let isSmallScreen = UIScreen.main.bounds.height <= 667 // iPhone SE, iPhone 8

    // ê·¸ë¦¬ë“œ ìƒì„±ì„ ìœ„í•œ í¬ê¸° ê³„ì‚°
    let gridWidth = calendarGridView.bounds.width
    let buttonWidth = gridWidth / 7.0
    let buttonHeight = isSmallScreen ? buttonWidth * 0.9 : buttonWidth

    // ì²« ë²ˆì§¸ ìš”ì¼ ì¡°ì • (0-based: 0 = ì¼ìš”ì¼, ..., 6 = í† ìš”ì¼)
    let firstWeekdayIndex = firstWeekday - 1

    // ê° ë‚ ì§œë³„ ë²„íŠ¼ ìƒì„±
    for day in 1...numberOfDaysInMonth {
        // ìš”ì¼ ê³„ì‚° (0: ì¼ìš”ì¼, 1: ì›”ìš”ì¼, ..., 6: í† ìš”ì¼)
        let components = DateComponents(year: year, month: month, day: day)
        guard let date = calendar.date(from: components) else { continue }
        let weekday = calendar.component(.weekday, from: date) - 1

        // ì£¼ì°¨ ê³„ì‚° (0: ì²«ì§¸ ì£¼, 1: ë‘˜ì§¸ ì£¼, ...)
        let weekOfMonth = (day + firstWeekdayIndex - 1) / 7

        // ë²„íŠ¼ ìƒì„± ë° ë°°ì¹˜
        let dayButton = createDayButton(day: day, weekday: weekday)
        dayButton.frame = CGRect(
            x: CGFloat(weekday) * buttonWidth,
            y: CGFloat(weekOfMonth) * buttonHeight,
            width: buttonWidth,
            height: buttonHeight
        )

        calendarGridView.addSubview(dayButton)

        // ì˜¤ëŠ˜ ë‚ ì§œ í‘œì‹œ
        if day == Calendar.current.component(.day, from: Date()) &&
            month == Calendar.current.component(.month, from: Date()) &&
            year == Calendar.current.component(.year, from: Date()) {
            addTodayIndicator(to: dayButton)
        }

        // ë°ì´í„°ê°€ ìˆëŠ” ë‚ ì§œ í‘œì‹œ
        if let dayCard = dayCardData[day] {
            if isShowingSymptoms {
                // ì¦ìƒ ëª¨ë“œ: ì‹¬ê°ë„ì— ë”°ë¥¸ í‘œì‹œ
                if !dayCard.symptoms.isEmpty {
                    let maxSeverity = dayCard.symptoms.max { $0.severity < $1.severity }?.severity ?? 1
                    addSymptomIndicator(to: dayButton, severity: maxSeverity)
                }
            } else {
                // ì¼ë°˜ ëª¨ë“œ: ì´ë¯¸ì§€ í‘œì‹œ
                if !dayCard.imageRecords.isEmpty,
                   let imageRecord = dayCard.imageRecords.first,
                   let thumbnailPath = imageRecord.thumbnailImagePath {
                    addImageIndicator(to: dayButton, imagePath: thumbnailPath)
                }
            }
        }
    }
}

```

## ğŸš¨ íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

### 1. ì´ë¯¸ì§€ ì²˜ë¦¬ ë° ë©”ëª¨ë¦¬ ìµœì í™”

**ë¬¸ì œ ìƒí™©**

- ì‚¬ìš©ìê°€ ì—¬ëŸ¬ ê³ í•´ìƒë„ ì´ë¯¸ì§€ë¥¼ ì•±ì— ì €ì¥í•˜ë©´ì„œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ê¸‰ì¦í•˜ëŠ” ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.
- íŠ¹íˆ ê°¤ëŸ¬ë¦¬ ë·°ì—ì„œ ìŠ¤í¬ë¡¤í•  ë•Œ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ì™€ ì§€ì—° í˜„ìƒì´ ë‘ë“œëŸ¬ì¡ŒìŠµë‹ˆë‹¤.

**í•´ê²° ë°©ë²•**

- ì´ë¯¸ì§€ë¥¼ ì›ë³¸ê³¼ ì¸ë„¤ì¼ë¡œ ë‚˜ëˆ„ì–´ ì €ì¥í•˜ê³ , ìƒí™©ì— ë§ê²Œ ì ì ˆí•œ í¬ê¸°ì˜ ì´ë¯¸ì§€ë¥¼ ë¡œë“œí•˜ë„ë¡ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.
- ì´ë¯¸ì§€ ìºì‹± ì‹œìŠ¤í…œì„ ë„ì…í•˜ì—¬ ë¶ˆí•„ìš”í•œ ë””ìŠ¤í¬ I/Oë¥¼ ì¤„ì˜€ìŠµë‹ˆë‹¤.
- ì´ë¯¸ì§€ ë¡œë”©ì„ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ê³ , í™”ë©´ì—ì„œ ë²—ì–´ë‚œ ì´ë¯¸ì§€ëŠ” ë©”ëª¨ë¦¬ì—ì„œ í•´ì œí•˜ë„ë¡ í–ˆìŠµë‹ˆë‹¤.

```swift
// ImageManager í´ë˜ìŠ¤ì˜ ìµœì í™”ëœ ì´ë¯¸ì§€ ë¡œë“œ ë©”ì„œë“œ
func loadThumbnailImage(from imagePath: String?) -> UIImage? {
    guard let imagePath = imagePath else { return nil }

    // ìºì‹œì— ìˆìœ¼ë©´ ìºì‹œì—ì„œ ë°˜í™˜
    if let cachedImage = imageCache[imagePath] {
        return cachedImage
    }

    let fileURL = getThumbnailImagesDirectory().appendingPathComponent(imagePath)

    if let data = try? Data(contentsOf: fileURL),
       let image = UIImage(data: data) {
        // ìºì‹œì— ì €ì¥
        imageCache[imagePath] = image
        return image
    }

    return UIImage(systemName: "photo")
}

// ViewControllerì—ì„œ ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
override func viewDidDisappear(_ animated: Bool) {
    super.viewDidDisappear(animated)

    // í™”ë©´ì„ ë²—ì–´ë‚  ë•Œ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
    if isBeingDismissed || isMovingFromParent {
        imageCache.removeAll()
    }
}

```

### 2. ë³µì¡í•œ ë·° ì „í™˜ ë° ìƒíƒœ ê´€ë¦¬

**ë¬¸ì œ ìƒí™©**

- í™ˆ í™”ë©´ì˜ ì¹´ë“œ ë·°ì™€ ìº˜ë¦°ë” ë·° ê°„ ì „í™˜ ì‹œ ì• ë‹ˆë©”ì´ì…˜ê³¼ ìƒíƒœ ìœ ì§€ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.
- íŠ¹íˆ ì—¬ëŸ¬ ê°œì˜ ì¹´ë“œê°€ ë™ì‹œì— í”Œë¦½ë˜ëŠ” ê³¼ì •ì—ì„œ íƒ€ì´ë° ì´ìŠˆì™€ ë¹„ë™ê¸° ì²˜ë¦¬ ë¬¸ì œê°€ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤.

**í•´ê²° ë°©ë²•**

- ìƒíƒœ ë³€ê²½ ë¡œì§ê³¼ ì• ë‹ˆë©”ì´ì…˜ ë¡œì§ì„ ëª…í™•íˆ ë¶„ë¦¬í–ˆìŠµë‹ˆë‹¤.
- ì• ë‹ˆë©”ì´ì…˜ì˜ ì™„ë£Œ ì‹œì ì— ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ì½œë°± íŒ¨í„´ì„ ë„ì…í–ˆìŠµë‹ˆë‹¤.
- DispatchQueueë¥¼ í™œìš©í•˜ì—¬ ì• ë‹ˆë©”ì´ì…˜ íƒ€ì´ë°ì„ ì œì–´í–ˆìŠµë‹ˆë‹¤.

```swift
func flipAllToCalendar() {
    // ì´ë¯¸ ìº˜ë¦°ë” ëª¨ë“œë©´ ë¬´ì‹œ
    guard !isCalendarMode else { return }

    // ë¨¼ì € ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
    cardCalendarView.flipAllToCalendar()

    // ì• ë‹ˆë©”ì´ì…˜ ë„ì¤‘(ì•½ê°„ì˜ ì§€ì—° ì‹œê°„)ì— ë²„íŠ¼ ìƒíƒœ ë³€ê²½
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) { [weak self] in
        guard let self = self else { return }

        UIView.animate(withDuration: 0.2) {
            self.calendarButton.isHidden = true
            self.backButton.isHidden = false
            self.view.layoutIfNeeded()
        }
    }

    // ë°ì´í„° ê°±ì‹  - ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ í˜¸ì¶œ
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.4) { [weak self] in
        guard let self = self else { return }

        // ë°ì´í„° ê°±ì‹  ëª…ì‹œì ìœ¼ë¡œ ì¬í˜¸ì¶œ
        if let currentMonth = self.cardCalendarView.getCurrentMonth() {
            self.cardCalendarView.updateData(year: self.viewModel.yearSubject.value, month: currentMonth)
        }
    }
}

```

### 3. Realm ë°ì´í„° ì‚­ì œ ì‹œ ì°¸ì¡° ë¬´ê²°ì„± ë¬¸ì œ

**ë¬¸ì œ ìƒí™©**

- DayCardì™€ ì—°ê²°ëœ ì´ë¯¸ì§€ ë˜ëŠ” ì¦ìƒ ê¸°ë¡ì„ ì‚­ì œí•  ë•Œ, ê´€ë ¨ íŒŒì¼ì´ ë””ìŠ¤í¬ì— ë‚¨ì•„ìˆëŠ” ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.
- ë˜í•œ, ë°ì´í„° ì‚­ì œ í›„ UI ê°±ì‹ ì´ ì¦‰ì‹œ ì´ë£¨ì–´ì§€ì§€ ì•Šì•„ ì‚¬ìš©ìì—ê²Œ í˜¼ë€ì„ ì£¼ì—ˆìŠµë‹ˆë‹¤.

**í•´ê²° ë°©ë²•**

- Realm ê°ì²´ ì‚­ì œ ì „ì— ê´€ë ¨ íŒŒì¼ ê²½ë¡œë¥¼ ë¯¸ë¦¬ ì•ˆì „í•˜ê²Œ ë³µì‚¬í•´ë‘ëŠ” íŒ¨í„´ì„ ì ìš©í–ˆìŠµë‹ˆë‹¤.
- íŒŒì¼ ì‚­ì œ ì‘ì—…ì€ ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œì—ì„œ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ë˜, UI ê°±ì‹ ì€ ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ì¦‰ì‹œ ì§„í–‰í–ˆìŠµë‹ˆë‹¤.
- ì•Œë¦¼ ì‹œìŠ¤í…œ(NotificationCenter)ì„ í™œìš©í•˜ì—¬ ë°ì´í„° ë³€ê²½ ì‚¬í•­ì„ ì•± ì „ì²´ì— ì „íŒŒí–ˆìŠµë‹ˆë‹¤.

```swift
func deleteCurrentDayCards() -> Observable<Void> {
    // í˜„ì¬ ë‚ ì§œì˜ DayCard IDë“¤ì„ ë¨¼ì € ê°€ì ¸ì˜µë‹ˆë‹¤
    let dayCards = dayCardRepository.getDayCards(year: year, month: month)
    let targetDayCards = dayCards.filter { $0.day == day }

    if targetDayCards.isEmpty {
        return Observable.error(NSError(domain: "DetailViewModel",
                                       code: -1,
                                       userInfo: [NSLocalizedDescriptionKey: "ì‚­ì œí•  DayCardë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"]))
    }

    // ê°ì²´ ì°¸ì¡° ëŒ€ì‹  IDë§Œ ì €ì¥
    let dayCardIDs = targetDayCards.map { $0.id }

    // IDë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‚­ì œ ìš”ì²­
    return dayCardRepository.deleteDayCardsByIDs(dayCardIDs)
        .do(onNext: { _ in
            // ì‚­ì œ ì„±ê³µ ì‹œ ì•Œë¦¼ ë°œì†¡
            NotificationCenter.default.post(
                name: Notification.Name(ImageDeletedNotification),
                object: nil
            )
        })
}

// DayCardRepository êµ¬í˜„
func deleteDayCardsByIDs(_ ids: [String]) -> Observable<Void> {
    return Observable.create { observer in
        let realm = self.getRealm()

        do {
            // íŠ¸ëœì­ì…˜ ì‹œì‘
            try realm.write {
                for id in ids {
                    guard let dayCard = realm.object(ofType: DayCard.self, forPrimaryKey: id) else {
                        print("DayCardRepository: ê²½ê³  - ID \(id)ì— í•´ë‹¹í•˜ëŠ” DayCardë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ")
                        continue
                    }

                    // ì¦ìƒ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ë° ì‚­ì œ
                    let symptoms = Array(dayCard.symptoms)
                    realm.delete(symptoms)

                    // ì´ë¯¸ì§€ ë ˆì½”ë“œ ê°€ì ¸ì˜¤ê¸° ë° ì‚­ì œ
                    let imageRecords = Array(dayCard.imageRecords)

                    // íŒŒì¼ ì‹œìŠ¤í…œì˜ ì´ë¯¸ì§€ íŒŒì¼ ì‚­ì œ (ë¹„ë™ê¸°ë¡œ ì²˜ë¦¬í•˜ì§€ë§Œ ì‚­ì œëŠ” í™•ì‹¤íˆ)
                    let imageManager = ImageManager.shared
                    for imageRecord in imageRecords {
                        // ì‚­ì œí•  ê²½ë¡œ ì •ë³´ ë¯¸ë¦¬ ë³µì‚¬
                        let originalPath = imageRecord.originalImagePath
                        let thumbnailPath = imageRecord.thumbnailImagePath

                        // ë ˆì½”ë“œ ìì²´ëŠ” Realmì—ì„œ ì‚­ì œ
                        realm.delete(imageRecord)

                        // íŒŒì¼ ì‹œìŠ¤í…œì˜ ì´ë¯¸ì§€ íŒŒì¼ ì‚­ì œ 
                        if originalPath != nil || thumbnailPath != nil {
                            DispatchQueue.global(qos: .background).async {
                                if let originalPath = originalPath {
                                    imageManager.deleteImageFile(path: originalPath, isOriginal: true)
                                }
                                if let thumbnailPath = thumbnailPath {
                                    imageManager.deleteImageFile(path: thumbnailPath, isOriginal: false)
                                }
                            }
                        }
                    }

                    // DayCard ì‚­ì œ
                    realm.delete(dayCard)
                }
            }

            observer.onNext(())
            observer.onCompleted()
        } catch {
            observer.onError(error)
        }

        return Disposables.create()
    }
}

```

### 4. ìœ„ì¹˜ ê¸°ë°˜ ì„œë¹„ìŠ¤ì™€ Kakao Maps API í†µí•©

**ë¬¸ì œ ìƒí™©**

- ìœ„ì¹˜ ê¶Œí•œ íšë“ë¶€í„° ì£¼ë³€ ë³‘ì› ê²€ìƒ‰ê¹Œì§€ì˜ íë¦„ì—ì„œ ë‹¤ì–‘í•œ ì˜¤ë¥˜ ìƒí™© ì²˜ë¦¬ê°€ í•„ìš”í–ˆìŠµë‹ˆë‹¤.
- ì‚¬ìš©ìê°€ ìœ„ì¹˜ ê¶Œí•œì„ ê±°ë¶€í•˜ê±°ë‚˜ ìœ„ì¹˜ ì„œë¹„ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ê²½ìš°ì—ë„ ì•±ì´ ì•ˆì •ì ìœ¼ë¡œ ë™ì‘í•´ì•¼ í–ˆìŠµë‹ˆë‹¤.
- Kakao Maps APIì™€ì˜ í†µì‹  ê³¼ì •ì—ì„œ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ ì²˜ë¦¬ì™€ ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… ì·¨ì†Œê°€ í•„ìš”í–ˆìŠµë‹ˆë‹¤.

**í•´ê²° ë°©ë²•**

- ìœ„ì¹˜ ê¶Œí•œ ìƒíƒœì— ë”°ë¥¸ ëª…í™•í•œ ìƒíƒœ ì „ì´ íë¦„ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.
- ê¸°ë³¸ ìœ„ì¹˜(ì„œìš¸)ë¥¼ ì‚¬ìš©í•˜ì—¬ ìœ„ì¹˜ ê¶Œí•œ ì—†ì´ë„ ê²€ìƒ‰ ê°€ëŠ¥í•˜ë„ë¡ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.
- ìœ„ì¹˜ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ê²½ìš° ì£¼ì†Œë¡œ ê²€ìƒ‰í•˜ì—¬ ìœ„ì¹˜ì •ë³´ë¥¼ ì„¤ì • í•  ìˆ˜ ìˆê²Œ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.
- Swiftì˜ Taskì™€ ì·¨ì†Œ ë©”ì»¤ë‹ˆì¦˜ì„ í™œìš©í•˜ì—¬ ë¹„ë™ê¸° ì‘ì—…ì„ ì•ˆì „í•˜ê²Œ ê´€ë¦¬í–ˆìŠµë‹ˆë‹¤.

```swift
// HospitalSearchViewModelì˜ ìœ„ì¹˜ ê¶Œí•œ ì²˜ë¦¬
private func handleLocationStatus() {
    let status = locationManager.authorizationStatus

    switch status {
    case .notDetermined:
        // ì•„ì§ ê²°ì •ë˜ì§€ ì•Šì€ ìƒíƒœ - ê¶Œí•œ ìš”ì²­
        locationManager.requestWhenInUseAuthorization()

    case .denied, .restricted:
        // ê±°ë¶€ëœ ìƒíƒœ - ì£¼ì†Œ ê²€ìƒ‰ UIë¡œ ì „í™˜
        shouldShowAddressSearchRelay.accept(true)
        errorRelay.accept("ìœ„ì¹˜ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ì£¼ì†Œ ê²€ìƒ‰ìœ¼ë¡œ ì „í™˜í•©ë‹ˆë‹¤.")
        isLoadingRelay.accept(false)

        // ê¸°ë³¸ ì„œìš¸ ìœ„ì¹˜ ì‚¬ìš©
        searchHospitalsNear(latitude: 37.5665, longitude: 126.9780)

    case .authorizedWhenInUse, .authorizedAlways:
        // ê¶Œí•œ í—ˆìš© ìƒíƒœ - ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ì‹œì‘
        locationManager.startUpdatingLocation()

    @unknown default:
        // ì•Œ ìˆ˜ ì—†ëŠ” ìƒíƒœ - ì£¼ì†Œ ê²€ìƒ‰ UIë¡œ ì „í™˜
        shouldShowAddressSearchRelay.accept(true)
        errorRelay.accept("ì•Œ ìˆ˜ ì—†ëŠ” ìœ„ì¹˜ ê¶Œí•œ ìƒíƒœì…ë‹ˆë‹¤. ì£¼ì†Œ ê²€ìƒ‰ìœ¼ë¡œ ì „í™˜í•©ë‹ˆë‹¤.")
        isLoadingRelay.accept(false)

        // ê¸°ë³¸ ì„œìš¸ ìœ„ì¹˜ ì‚¬ìš©
        searchHospitalsNear(latitude: 37.5665, longitude: 126.9780)
    }
}

// ì•ˆì „í•œ ë¹„ë™ê¸° ì‘ì—… ê´€ë¦¬
private func searchHospitalsNear(latitude: Double, longitude: Double) {
    isLoadingRelay.accept(true)

    // ì´ì „ Task ì·¨ì†Œ
    searchTask?.cancel()

    // ìƒˆ Task ì‹œì‘
    searchTask = Task {
        do {
            guard !Task.isCancelled else { return }
            let hospitals = try await KakaoMapManager.shared.searchHospitals(
                latitude: latitude,
                longitude: longitude
            )

            // ì·¨ì†Œ í™•ì¸
            guard !Task.isCancelled else { return }

            DispatchQueue.main.async { [weak self] in
                guard let self = self else { return }
                self.hospitalsRelay.accept(hospitals)
                self.isLoadingRelay.accept(false)

                if hospitals.isEmpty {
                    self.errorRelay.accept("ì£¼ë³€ì— 24ì‹œ ë™ë¬¼ë³‘ì›ì´ ì—†ìŠµë‹ˆë‹¤.")
                } else {
                    self.errorRelay.accept(nil)
                }
            }
        } catch {
            guard !Task.isCancelled else { return }

            DispatchQueue.main.async { [weak self] in
                guard let self = self else { return }
                self.hospitalsRelay.accept([])
                self.isLoadingRelay.accept(false)
                self.errorRelay.accept("ë³‘ì› ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: \(error.localizedDescription)")
            }
        }
    }
}

// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
func cleanup() {
    locationManager.delegate = nil
    locationManager.stopUpdatingLocation()
    searchTask?.cancel() // Task ì·¨ì†Œ ì¶”ê°€
    searchTask = nil
}

```

## ğŸ¯ í–¥í›„ ê°œì„ ì 

- **ë‹¤êµ­ì–´ ì§€ì›**: ì˜ì–´, ì¼ë³¸ì–´ ë“± ë‹¤êµ­ì–´ ì§€ì›ìœ¼ë¡œ ê¸€ë¡œë²Œ ì‚¬ìš©ì í™•ë³´
- **ë°ì´í„° ë°±ì—… ë° ë³µì›**: íŒŒì¼ ì••ì¶• ê¸°ë°˜ ë°ì´í„° ë°±ì—… ë° ë³µì› ê¸°ëŠ¥ ì¶”ê°€
- **í…ŒìŠ¤íŠ¸ ì½”ë“œ ì‘ì„±**: ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ë° UI í…ŒìŠ¤íŠ¸ ì¶”ê°€ë¡œ ì•± ì•ˆì •ì„± í–¥ìƒ
- **ì„±ëŠ¥ ìµœì í™”**: ëŒ€ìš©ëŸ‰ ì´ë¯¸ì§€ ì²˜ë¦¬ì™€ ë©”ëª¨ë¦¬ ì»¤ìŠ¤í…€ ìºì‹± ì •ì±… êµ¬í˜„

